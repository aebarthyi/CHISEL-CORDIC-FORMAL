package CORDIC

import chisel3._
import chisel3.util._

object CordicTrigConstants {
  val TRIG_CORDIC_K_DBL: Double = 0.6072529350088813 // Gain of CORDIC rotation/vectoring

  /* Converts a Double to a BigInt representing a fixed-point number */
  def doubleToFixed(x: Double, fractionalBits: Int, width: Int): BigInt = {
    val scaled = BigDecimal(x) * BigDecimal(BigInt(1) << fractionalBits)
    val rounded = scaled.setScale(0, BigDecimal.RoundingMode.HALF_UP).toBigInt
    val maxVal = (BigInt(1) << (width - 1)) - 1
    val minVal = -(BigInt(1) << (width - 1))
    rounded.max(minVal).min(maxVal)
  }

  def getAtanLUT(fractionalBits: Int, width: Int, numEntries: Int): Seq[SInt] = {
    (0 until numEntries).map { i =>
      val angleRad = math.atan(math.pow(2.0, -i))
      doubleToFixed(angleRad, fractionalBits, width).S(width.W)
    }
  }

  // CORDIC operation modes
  object Mode extends ChiselEnum {
    val SinCos, ArctanMagnitude = Value
  }
}

class CordicTrig(val width: Int, val cycleCount: Int, val integerBits: Int = 3, val magnitudeCorrection: Boolean = true) extends Module {
  import CordicTrigConstants.Mode
  
  // Parameter Validations
  require(width > 0, "Width must be positive")
  require(cycleCount > 0, "Cycle count must be positive")
  require(integerBits >= 1, "Integer bits must be at least 1 for the sign bit.")
  val fractionalBits: Int = width - 1 - integerBits // 1 bit for sign
  require(fractionalBits > 0, s"Fractional bits must be positive. Check width ($width) vs integerBits ($integerBits).")

  val io = IO(new Bundle {
    // Control
    val start = Input(Bool())
    val mode = Input(Mode())

    // Data Inputs
    val targetTheta = Input(SInt(width.W)) 
    val inputX = Input(SInt(width.W))      
    val inputY = Input(SInt(width.W))      

    // Data Outputs
    val done = Output(Bool())
    val cosOut = Output(SInt(width.W))   
    val sinOut = Output(SInt(width.W))    
    val arctanOut = Output(SInt(width.W))
    val magnitudeOut = Output(SInt(width.W))
  })

  // --- Fixed-point constants for CORDIC calculations ---
  val K_fixed = CordicTrigConstants.doubleToFixed(CordicTrigConstants.TRIG_CORDIC_K_DBL, fractionalBits, width).S(width.W)

  val X_INIT_SINCOS_fixed = if (magnitudeCorrection) {
    K_fixed
  } else {
    CordicTrigConstants.doubleToFixed(1.0, fractionalBits, width).S(width.W)
  }
  val Y_INIT_SINCOS_fixed = 0.S(width.W)

  // Arctan lookup table (ROM). Contents generated by getAtanLUT.
  val atanLUT = VecInit(CordicTrigConstants.getAtanLUT(fractionalBits, width, cycleCount))

  // --- State Machine Definition ---
  object s extends ChiselEnum {
    val idle, busy, done = Value
  }
  val state = RegInit(s.idle)

  // --- Registers for CORDIC iterative values ---
  val x_reg = Reg(SInt(width.W))
  val y_reg = Reg(SInt(width.W))
  val z_reg = Reg(SInt(width.W)) 
  // iter_count goes from 0 to cycleCount-1 for iterations, then to cycleCount to signal completion
  val iter_count = Reg(UInt(log2Ceil(cycleCount + 1).W))
  val currentMode = Reg(Mode())  // Store operation mode during processing

  // --- Default output values ---
  io.done := false.B
  io.cosOut := 0.S    
  io.sinOut := 0.S
  io.arctanOut := 0.S
  io.magnitudeOut := 0.S

  // --- State Machine Logic ---
  switch(state) {
    is(s.idle) {
      when(io.start) {
        currentMode := io.mode
        
        when(io.mode === Mode.ArctanMagnitude) {
          x_reg := io.inputX
          y_reg := io.inputY
          z_reg := 0.S(width.W) 
        }.otherwise { // Sin/Cos (Rotation mode)
          x_reg := X_INIT_SINCOS_fixed // Start with vector (1,0) effectively
          y_reg := Y_INIT_SINCOS_fixed
          z_reg := io.targetTheta     
        }
        iter_count := 0.U
        state := s.busy
      }
    }

    is(s.busy) {
      // Perform iterations as long as iter_count < cycleCount
      when(iter_count < cycleCount.U) {
        val current_i = iter_count // Current iteration index, used for shifts and LUT access

        val y_shifted = y_reg >> current_i
        val x_shifted = x_reg >> current_i
        
        val delta_theta = atanLUT(current_i)
        val direction = Wire(SInt(2.W))      // Direction of rotation/vectoring (+1 or -1)

        when(currentMode === Mode.ArctanMagnitude) { // Vectoring mode (calculating ArcTan)
          val d_vec = Mux(y_reg >= 0.S, 1.S, -1.S)
          direction := d_vec // Assign to the common 'direction' wire

          x_reg := x_reg + (direction * y_shifted) 
          y_reg := y_reg - (direction * x_shifted) 
          z_reg := z_reg + (direction * delta_theta)

        }.otherwise { // Rotation mode (calculating Sin/Cos)
          val d_rot = Mux(z_reg >= 0.S, 1.S, -1.S)
          direction := d_rot // Assign to the common 'direction' wire
          
          x_reg := x_reg - (direction * y_shifted) // x_new = x_old - d*y_shifted
          y_reg := y_reg + (direction * x_shifted) // y_new = y_old + d*x_shifted
          z_reg := z_reg - (direction * delta_theta) // z_new = z_old - d*angle
        }
        iter_count := iter_count + 1.U
      }.otherwise {
        state := s.done
      }
    }

    is(s.done) {
      io.done := true.B

      when(currentMode === Mode.ArctanMagnitude) {
        val magnitude_uncorrected = x_reg
        
        if (magnitudeCorrection) {
          val magnitude_full_prod = magnitude_uncorrected * K_fixed
          io.magnitudeOut := (magnitude_full_prod >> fractionalBits.U).asSInt
        } else {
          io.magnitudeOut := magnitude_uncorrected
        }
        
        io.arctanOut := z_reg
        io.cosOut := 0.S
        io.sinOut := 0.S
      }.otherwise {
        io.cosOut := x_reg
        io.sinOut := y_reg
        io.arctanOut := 0.S
        io.magnitudeOut := 0.S
      }
      state := s.idle
    }
  }
}

